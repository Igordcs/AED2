a) A tabela deve armazenar registros que contêm pelo menos 5 campos. 
    A definição do registro/campos a serem gerenciados é de livre escolha, 
    desde que seja algo adequado ao ambiente acadêmico;

r. Foi criada a Tabela e o registro poke_info, que contém 5 campos (3 char* e 2 int);

b) Os campos do tipo string devem ter alocação estática (com tamanho máximo predefinido);

r. Primeiramente foi feito o desenvolvimento do projeto com alocação estática (poke_name[80], tipos[30]).

c) Utilize três índices na tabela: um índice BST, um AVL e um RB, cada um em um campo diferente;

r. A tabela contém os 3 indices --> indice_bst (chave é o número do pokemon), indice_avl (chave é o nome do pokemon)
    indice_rb(chave é o poder total do pokemon)

d) Os dados dos registros devem ser armazenados em um arquivo binário sequencial, conforme exemplificado no projeto "arquivo 3";

r. todos os dados referentes aos registros adicionados estão em "dados.dat"

e) Cada índice deve ser salvo em um arquivo próprio, conforme exemplificado no projeto "arquivo 1". 
    OBS: durante a execução do programa, os índices devem ser mantidos em memória RAM, sendo passados 
    para o arquivo apenas quando o usuário escolher a opção "sair" do programa;

r. Cada índice possui um arquivo com seu nome e salvando seus respectivos valores.

f) Implemente a função de adicionar registro, a qual insere o registro no arquivo de dados e atualiza os três índices;

r. A função adicionar registro foi implementada. Está no sgbd.c:198.

g) Implemente a função de remover registro, que remove apenas as referências ao registro nos índices, sem a necessidade de modificar o arquivo de dados;

r. A função de remover foi implementada. Está no sgbd.c:116.

h) Implemente uma função de busca para cada índice. Esta função deve imprimir na tela todos os dados satélite do registro referenciado pelo índice passado como parâmetro;

r. Cada indice possui uma função de busca e cada uma está no arquivo sgbd.c com sua respectiva arvore.

i) Implemente uma função para exibir os registros ordenados de acordo com cada um dos índices (inorder);

r. As funções imprimem em ordem crescente de seu índice (AVL -> NOME, BST->NUMERO, RB->PODERTOTAL)

j) Implemente a função main que permite ao usuário utilizar o sistema com todas as opções de funções implementadas;

r. Função main no arquivo main com as funções implementadas.

k) Ponto extra: Implemente uma tabela de relocação, que mantém o registro de cada elemento excluído para reutilizar o espaço no arquivo de dados em futuras inserções.

r. Implementada a tabela de realocação "retab", armazena a referencia de onde o registro apagado começa
    e a quantidade de letras do registro, pois é necessário para quando estivermos trabalhando com alocação
    dinâmica.

l) Ponto extra: Acrescente ao menos um campo string de tamanho variável. A forma de manipulação no arquivo
    de dados precisará adotar alguma estratégia de separação de campos e registros, por exemplo, formato
    XML, JSON, caractere separador, etc. Certifique-se de implementar a alocação dinâmica de memória para
    armazenar as strings de tamanho variável. Além disso, explique e implemente uma estratégia adequada 
    para a manipulação desses campos, como o uso de delimitadores ou formatos de serialização (XML, JSON,
    etc.), garantindo a integridade dos dados ao ler e gravar no arquivo de dados. É importante observar
    que essa funcionalidade também terá impactos na implementação da tabela de relocação de dados. 
    A parte referente ao gerenciamento de strings de tamanho variável na memória RAM está exemplificado 
    no projeto "arquivo 2";

r. Existem 3 campos de alocação dinâmica. A forma de manipulação utilizada foi caracter separador (',')
    essa alteração faz uma mudança crítica na lógica da tabela de realocação, onde precisamos calcular
    se o elemento a ser inserido é maior ou menor que o espaço disponível pelo elemento removido. Quando
    o tamanho disponível é maior que o novo registro, é preenchido o espaço de caracteres com espaços,
    afim de evitar bugs críticos no funcionamento do programa.
